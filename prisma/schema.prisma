// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Process {
  id          String       @id @default(cuid())
  name        String
  description String?
  status      String       @default("paused") // paused, running, archived
  workflows   Workflow[]
  objectTypes ObjectType[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model ObjectType {
  id          String            @id @default(cuid())
  processId   String
  process     Process           @relation(fields: [processId], references: [id], onDelete: Cascade)
  name        String            // "Invoice", "Purchase Order"
  description String?
  fields      FieldDefinition[]
  workItems   WorkItem[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@unique([processId, name])
}

model FieldDefinition {
  id           String     @id @default(cuid())
  objectTypeId String
  objectType   ObjectType @relation(fields: [objectTypeId], references: [id], onDelete: Cascade)
  name         String     // Field key: "invoiceNumber", "amount"
  label        String     // Display label: "Invoice Number", "Amount"
  type         String     // "text", "number", "date", "select", "checkbox", "textarea"
  required     Boolean    @default(false)
  order        Int        @default(0)
  config       String     @default("{}") // JSON: validation config (min, max, pattern, options, etc.)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([objectTypeId, name])
}

model Workflow {
  id         String     @id @default(cuid())
  processId  String
  process    Process    @relation(fields: [processId], references: [id], onDelete: Cascade)
  name       String
  isSubflow  Boolean    @default(false)
  version    Int        @default(1)
  tasks      Task[]
  routes     Route[]
  workItems  WorkItem[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
}

model Task {
  id           String     @id @default(cuid())
  workflowId   String
  workflow     Workflow   @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  type         String     // begin, end, user, decision, service, broadcast, rendezvous, subflow
  name         String
  position     String     // JSON: {x, y}
  config       String     // JSON: type-specific config

  inboundRoutes  Route[]    @relation("TargetTask")
  outboundRoutes Route[]    @relation("SourceTask")
  workItems      WorkItem[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Route {
  id           String   @id @default(cuid())
  workflowId   String
  workflow     Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  sourceTaskId String
  targetTaskId String
  sourceTask   Task     @relation("SourceTask", fields: [sourceTaskId], references: [id], onDelete: Cascade)
  targetTask   Task     @relation("TargetTask", fields: [targetTaskId], references: [id], onDelete: Cascade)
  label        String?
  condition    String?  // JSON: for decision tasks

  createdAt    DateTime @default(now())
}

model User {
  id           String     @id @default(cuid())
  email        String     @unique
  name         String
  role         String     @default("user") // admin, user
  groups       UserGroup[]
  claimedItems WorkItem[] @relation("ClaimedItems")
  createdAt    DateTime   @default(now())
}

model Group {
  id                   String      @id @default(cuid())
  name                 String
  description          String?
  lastRoundRobinUserId String?     // Track last assigned user for round-robin
  users                UserGroup[]
  createdAt            DateTime    @default(now())
}

model UserGroup {
  userId    String
  groupId   String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([userId, groupId])
}

model WorkItem {
  id            String      @id @default(cuid())
  workflowId    String
  workflow      Workflow    @relation(fields: [workflowId], references: [id])
  currentTaskId String
  currentTask   Task        @relation(fields: [currentTaskId], references: [id])

  // Business object (embedded metadata)
  objectType    String      // "invoice", "purchase_order", etc.
  objectData    String      // JSON: the actual business object fields
  objectTypeId  String?     // Optional FK to ObjectType definition
  objectTypeRef ObjectType? @relation(fields: [objectTypeId], references: [id])

  // Status tracking
  status        String      @default("active") // active, completed, cancelled
  priority      String      @default("normal") // low, normal, high, urgent

  // Assignment
  claimedById   String?
  claimedBy     User?       @relation("ClaimedItems", fields: [claimedById], references: [id])
  claimedAt     DateTime?

  // Audit trail
  history       WorkItemHistory[]

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model WorkItemHistory {
  id          String   @id @default(cuid())
  workItemId  String
  workItem    WorkItem @relation(fields: [workItemId], references: [id], onDelete: Cascade)
  taskId      String
  taskName    String
  action      String   // "created", "arrived", "claimed", "released", "auto-routed", "completed"
  routeLabel  String?
  userId      String?
  notes       String?
  timestamp   DateTime @default(now())
}
